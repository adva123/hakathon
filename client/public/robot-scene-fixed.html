<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>סצנת Candy Robot</title>
    <style>
      :root {
        color-scheme: light;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        overflow: hidden;
        background: #aeefff;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      canvas {
        display: block;
      }
      #hud {
        position: fixed;
        inset: 12px 12px auto auto;
        direction: rtl;
        background: rgba(255, 255, 255, 0.78);
        border: 1px solid rgba(0, 0, 0, 0.08);
        border-radius: 12px;
        padding: 10px 12px;
        backdrop-filter: blur(6px);
        max-width: min(520px, calc(100vw - 24px));
        line-height: 1.35;
      }
      #hud strong {
        display: inline-block;
        margin-left: 6px;
      }
      #hud small {
        display: block;
        opacity: 0.75;
        margin-top: 4px;
      }
      #status {
        white-space: pre-wrap;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="hud">
      <div><strong>סטטוס:</strong> <span id="status">טוען…</span></div>
      <small>גרור עם העכבר לסיבוב המצלמה. גלגלת לזום.</small>
    </div>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      const statusEl = document.getElementById('status');
      const setStatus = (text) => {
        if (statusEl) statusEl.textContent = text;
      };

      try {
        setStatus('מאתחל רנדר…');

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaeefff);
        scene.fog = new THREE.FogExp2(0xdaf8ff, 0.045);

        const camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          250
        );
        camera.position.set(0.8, 4.2, 11.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.05;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 2.2, 0);
        controls.minDistance = 6;
        controls.maxDistance = 22;
        controls.maxPolarAngle = Math.PI * 0.48;

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.55));
        const sun = new THREE.DirectionalLight(0xffffff, 1.25);
        sun.position.set(9, 14, 7);
        sun.castShadow = true;
        sun.shadow.mapSize.set(2048, 2048);
        sun.shadow.camera.near = 1;
        sun.shadow.camera.far = 60;
        sun.shadow.camera.left = -18;
        sun.shadow.camera.right = 18;
        sun.shadow.camera.top = 18;
        sun.shadow.camera.bottom = -18;
        sun.shadow.bias = -0.00006;
        scene.add(sun);

        const fill = new THREE.DirectionalLight(0xffd6f1, 0.45);
        fill.position.set(-10, 8, -10);
        scene.add(fill);

        // --- Helpers: textures (no external assets) ---
        function makeCandyBoardTexture() {
          const size = 512;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');

          // Base
          const grad = ctx.createLinearGradient(0, 0, size, size);
          grad.addColorStop(0, '#ffb3d9');
          grad.addColorStop(0.5, '#ffe49b');
          grad.addColorStop(1, '#b6f4ff');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, size, size);

          // Grid + candy dots
          const cells = 8;
          const cell = size / cells;
          ctx.lineWidth = 6;
          ctx.strokeStyle = 'rgba(255,255,255,0.65)';
          ctx.fillStyle = 'rgba(255,255,255,0.14)';
          for (let y = 0; y < cells; y++) {
            for (let x = 0; x < cells; x++) {
              const px = x * cell;
              const py = y * cell;
              const r = 18;
              ctx.beginPath();
              ctx.roundRect(px + 10, py + 10, cell - 20, cell - 20, r);
              ctx.fill();
              ctx.stroke();

              const cx = px + cell * 0.5;
              const cy = py + cell * 0.5;
              const hue = (x * 38 + y * 25) % 360;
              ctx.beginPath();
              ctx.fillStyle = `hsla(${hue}, 85%, 62%, 0.85)`;
              ctx.arc(cx, cy, 18, 0, Math.PI * 2);
              ctx.fill();

              ctx.beginPath();
              ctx.fillStyle = 'rgba(255,255,255,0.55)';
              ctx.arc(cx - 6, cy - 6, 6, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          return new THREE.CanvasTexture(canvas);
        }

        function makeLollipopTexture() {
          const size = 256;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#fff3fb';
          ctx.fillRect(0, 0, size, size);

          const cx = size / 2;
          const cy = size / 2;
          for (let i = 0; i < 80; i++) {
            const t = i / 80;
            const ang = t * Math.PI * 10;
            const r = 10 + t * 110;
            const x = cx + Math.cos(ang) * r;
            const y = cy + Math.sin(ang) * r;
            ctx.beginPath();
            ctx.fillStyle = i % 2 === 0 ? '#ff5bb5' : '#4fd6ff';
            ctx.arc(x, y, 11 - t * 5, 0, Math.PI * 2);
            ctx.fill();
          }
          return new THREE.CanvasTexture(canvas);
        }

        const boardTex = makeCandyBoardTexture();
        boardTex.colorSpace = THREE.SRGBColorSpace;
        boardTex.wrapS = boardTex.wrapT = THREE.RepeatWrapping;
        boardTex.repeat.set(2, 2);

        const lollipopTex = makeLollipopTexture();
        lollipopTex.colorSpace = THREE.SRGBColorSpace;

        // --- Environment ---
        const groundMat = new THREE.MeshStandardMaterial({
          map: boardTex,
          roughness: 0.62,
          metalness: 0.0
        });
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(60, 60), groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Candy frame border
        const frameMat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          roughness: 0.22,
          metalness: 0.05,
          clearcoat: 1,
          clearcoatRoughness: 0.18
        });
        const frame = new THREE.Mesh(
          new THREE.TorusGeometry(16, 0.55, 18, 90),
          frameMat
        );
        frame.rotation.x = Math.PI / 2;
        frame.position.y = 0.22;
        frame.castShadow = true;
        scene.add(frame);

        // Gumdrop hills
        function addGumdropHill(x, z, radius, height, color) {
          const geom = new THREE.SphereGeometry(radius, 36, 28);
          const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.65 });
          const mesh = new THREE.Mesh(geom, mat);
          mesh.scale.y = height;
          mesh.position.set(x, -radius * height * 0.42, z);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
        }
        addGumdropHill(-14, -14, 8, 0.55, 0xff7ec9);
        addGumdropHill(16, -10, 10, 0.48, 0x7ee7ff);
        addGumdropHill(0, -22, 14, 0.42, 0xffd56a);

        // Lollipop trees
        const stickMat = new THREE.MeshStandardMaterial({ color: 0xf7d7b7, roughness: 0.9 });
        const lolliMat = new THREE.MeshStandardMaterial({ map: lollipopTex, roughness: 0.45 });

        function addLollipopTree(x, z, scale = 1) {
          const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12 * scale, 0.16 * scale, 2.3 * scale, 16),
            stickMat
          );
          trunk.position.set(x, 1.15 * scale, z);
          trunk.castShadow = true;
          scene.add(trunk);

          const candy = new THREE.Mesh(
            new THREE.CylinderGeometry(0.95 * scale, 0.95 * scale, 0.24 * scale, 32),
            lolliMat
          );
          candy.position.set(x, 2.45 * scale, z);
          candy.rotation.z = Math.PI / 2;
          candy.castShadow = true;
          scene.add(candy);

          const rim = new THREE.Mesh(
            new THREE.TorusGeometry(0.95 * scale, 0.08 * scale, 14, 42),
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.35 })
          );
          rim.position.copy(candy.position);
          rim.rotation.y = Math.PI / 2;
          rim.castShadow = true;
          scene.add(rim);
        }

        for (let i = 0; i < 18; i++) {
          const x = (Math.random() - 0.5) * 42;
          const z = (Math.random() - 0.5) * 42;
          if (x * x + z * z < 12 * 12) continue;
          addLollipopTree(x, z, 0.75 + Math.random() * 0.7);
        }

        // Floating candy clouds
        const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.95 });
        function addCloud(x, y, z, s) {
          const g = new THREE.Group();
          const parts = 5 + Math.floor(Math.random() * 4);
          for (let i = 0; i < parts; i++) {
            const p = new THREE.Mesh(new THREE.SphereGeometry(0.6 * s, 18, 14), cloudMat);
            p.position.set(
              (Math.random() - 0.5) * 1.9 * s,
              (Math.random() - 0.3) * 0.8 * s,
              (Math.random() - 0.5) * 1.6 * s
            );
            g.add(p);
          }
          g.position.set(x, y, z);
          scene.add(g);
          return g;
        }
        const clouds = [
          addCloud(-6, 9, -14, 2.2),
          addCloud(10, 10, -10, 2.6),
          addCloud(-14, 8, -2, 1.9)
        ];

        // --- Candy Robot (gentleman) ---
        const robot = new THREE.Group();
        robot.position.set(0, 1.55, 0);
        scene.add(robot);

        const ceramic = new THREE.MeshPhysicalMaterial({
          color: 0xf7f2ff,
          roughness: 0.22,
          metalness: 0.05,
          clearcoat: 1,
          clearcoatRoughness: 0.15
        });
        const gold = new THREE.MeshStandardMaterial({
          color: 0xf4c24c,
          metalness: 1,
          roughness: 0.25
        });
        const darkRed = new THREE.MeshStandardMaterial({
          color: 0xd7263d,
          roughness: 0.45,
          metalness: 0.05
        });
        const beardMat = new THREE.MeshStandardMaterial({ color: 0xc06b2b, roughness: 0.85 });
        const gemMat = new THREE.MeshStandardMaterial({
          color: 0x38ff9c,
          emissive: 0x18ff86,
          emissiveIntensity: 1.2,
          roughness: 0.18,
          metalness: 0.05
        });

        // Body
        const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.78, 1.22, 8, 22), ceramic);
        torso.castShadow = true;
        torso.receiveShadow = true;
        robot.add(torso);

        // Head
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.62, 28, 24), ceramic);
        head.position.y = 1.55;
        head.castShadow = true;
        robot.add(head);

        // Eyes
        const eyeWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.25 });
        const pupil = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });
        function addEye(x) {
          const g = new THREE.Group();
          const w = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 12), eyeWhite);
          const p = new THREE.Mesh(new THREE.SphereGeometry(0.055, 16, 12), pupil);
          p.position.set(0.04, -0.02, 0.11);
          w.castShadow = true;
          p.castShadow = true;
          g.add(w, p);
          g.position.set(x, 1.62, 0.54);
          robot.add(g);
          return g;
        }
        addEye(-0.18);
        addEye(0.18);

        // Beard (ginger)
        const beard = new THREE.Mesh(new THREE.SphereGeometry(0.52, 26, 18), beardMat);
        beard.position.set(0, 1.38, 0.48);
        beard.scale.set(1.1, 0.7, 0.9);
        beard.castShadow = true;
        robot.add(beard);

        // Top hat
        const hat = new THREE.Group();
        const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.72, 0.72, 0.08, 32), darkRed);
        const crown = new THREE.Mesh(new THREE.CylinderGeometry(0.52, 0.58, 0.62, 32), darkRed);
        crown.position.y = 0.34;
        brim.castShadow = true;
        crown.castShadow = true;
        hat.add(brim, crown);
        hat.position.set(0, 2.22, 0);
        robot.add(hat);

        // Bow tie
        const bow = new THREE.Group();
        const bowLeft = new THREE.Mesh(new THREE.SphereGeometry(0.18, 18, 14), darkRed);
        bowLeft.scale.set(1.3, 0.85, 0.65);
        bowLeft.position.x = -0.22;
        const bowRight = bowLeft.clone();
        bowRight.position.x = 0.22;
        const knot = new THREE.Mesh(new THREE.SphereGeometry(0.09, 16, 12), gold);
        bow.add(bowLeft, bowRight, knot);
        bow.position.set(0, 0.88, 0.74);
        bow.rotation.x = 0.12;
        bow.traverse((o) => {
          if (o.isMesh) o.castShadow = true;
        });
        robot.add(bow);

        // Chest gem
        const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.16, 0), gemMat);
        gem.position.set(0, 0.56, 0.78);
        gem.castShadow = true;
        robot.add(gem);

        // Limbs (hierarchical for animation)
        function makeArm(side) {
          const g = new THREE.Group();
          g.position.set(0.82 * side, 0.85, 0.0);
          robot.add(g);

          const shoulder = new THREE.Mesh(new THREE.SphereGeometry(0.14, 18, 14), gold);
          shoulder.castShadow = true;
          g.add(shoulder);

          const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.14, 0.72, 16), ceramic);
          upper.position.y = -0.45;
          upper.castShadow = true;
          g.add(upper);

          const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.12, 18, 14), gold);
          elbow.position.y = -0.86;
          elbow.castShadow = true;
          g.add(elbow);

          const lower = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.12, 0.62, 16), ceramic);
          lower.position.y = -1.18;
          lower.castShadow = true;
          g.add(lower);

          const hand = new THREE.Mesh(new THREE.SphereGeometry(0.13, 18, 14), ceramic);
          hand.position.y = -1.5;
          hand.castShadow = true;
          g.add(hand);

          return g;
        }

        function makeLeg(side) {
          const g = new THREE.Group();
          g.position.set(0.36 * side, -0.72, 0.0);
          robot.add(g);

          const hip = new THREE.Mesh(new THREE.SphereGeometry(0.15, 18, 14), gold);
          hip.castShadow = true;
          g.add(hip);

          const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.13, 0.15, 0.86, 16), ceramic);
          upper.position.y = -0.52;
          upper.castShadow = true;
          g.add(upper);

          const knee = new THREE.Mesh(new THREE.SphereGeometry(0.13, 18, 14), gold);
          knee.position.y = -0.98;
          knee.castShadow = true;
          g.add(knee);

          const lower = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.13, 0.82, 16), ceramic);
          lower.position.y = -1.42;
          lower.castShadow = true;
          g.add(lower);

          const foot = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.14, 0.48), darkRed);
          foot.position.set(0, -1.87, 0.18);
          foot.castShadow = true;
          g.add(foot);

          return g;
        }

        const armL = makeArm(-1);
        const armR = makeArm(1);
        const legL = makeLeg(-1);
        const legR = makeLeg(1);

        // Shadow anchor
        const shadowBlob = new THREE.Mesh(
          new THREE.CircleGeometry(1.1, 32),
          new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.12 })
        );
        shadowBlob.rotation.x = -Math.PI / 2;
        shadowBlob.position.y = 0.02;
        scene.add(shadowBlob);

        // --- Animation loop ---
        const clock = new THREE.Clock();
        const robotPathRadius = 6.8;
        const baseY = robot.position.y;

        setStatus('רץ ✅');

        function animate() {
          const t = clock.getElapsedTime();
          const walk = t * 3.2;

          // Walk cycle
          const swing = Math.sin(walk) * 0.55;
          const swingOpp = Math.sin(walk + Math.PI) * 0.55;
          legL.rotation.x = swing;
          legR.rotation.x = swingOpp;
          armL.rotation.x = swingOpp * 0.9;
          armR.rotation.x = swing * 0.9;
          robot.position.y = baseY + Math.sin(walk * 2) * 0.06;
          torso.rotation.z = Math.sin(walk) * 0.04;
          head.rotation.y = Math.sin(t * 0.7) * 0.08;

          // Move on a gentle loop
          const angle = t * 0.28;
          robot.position.x = Math.cos(angle) * robotPathRadius;
          robot.position.z = Math.sin(angle) * robotPathRadius;
          robot.rotation.y = -angle + Math.PI / 2;

          shadowBlob.position.x = robot.position.x;
          shadowBlob.position.z = robot.position.z;

          // Gem pulse
          gem.material.emissiveIntensity = 1.05 + Math.sin(t * 4.2) * 0.25;
          gem.rotation.y = t * 2.0;
          gem.rotation.x = t * 1.4;

          // Cloud drift
          for (let i = 0; i < clouds.length; i++) {
            const c = clouds[i];
            c.position.x += 0.004 + i * 0.0008;
            if (c.position.x > 24) c.position.x = -24;
          }

          controls.update();
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);

        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        });
      } catch (err) {
        console.error(err);
        const message = err && err.message ? err.message : String(err);
        setStatus('שגיאה ❌\n' + message);
      }
    </script>
  </body>
</html>
